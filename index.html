<!DOCTYPE html>
<html lang="ar">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>خريطة تفاعلية نظيفة</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background-color: black;
    height: 100vh;
    overflow: auto;
    display: flex;
    justify-content: center;
    align-items: flex-start;
  }

  svg {
    display: block;
    max-width: 100vw;
    height: 100%;
    width: auto;
  }

  .image-mapper-shape {
    fill: transparent;
    stroke: yellow;
    stroke-width: 2px;
    transform-origin: center center;
    transition: transform 0.3s ease, filter 0.3s ease;
  }
  .image-mapper-shape#red { stroke: red; }

  .zoom-part {
    pointer-events: none;
    transition: transform 0.3s ease, filter 0.3s ease, opacity 0.3s ease;
    image-rendering: auto;
  }
</style>
</head>
<body>

<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2048 4908" preserveAspectRatio="xMidYMid meet">
  <defs id="clip-defs"></defs>

  <g id="group-1" transform="translate(0,0)">
    <image href="image/1.png" width="1024" height="2454" data-image-url="image/1.png" class="base-image"/>
    <a href="block/physio/1.pdf" target="_blank"><rect x="254" y="423" width="114" height="467" class="image-mapper-shape"/></a>
    <a href="block/histo/1.pdf" target="_blank"><rect x="253" y="1403" width="114" height="438" class="image-mapper-shape"/></a>
    <a href="block/physio/2.pdf" target="_blank"><rect x="484" y="314" width="113" height="459" class="image-mapper-shape"/></a>
    <a href="block/pharma/1.pdf" target="_blank"><rect x="599" y="422" width="112" height="471" class="image-mapper-shape"/></a>
    <a href="block/physio/3.pdf" target="_blank"><rect x="488" y="1838" width="108" height="441" class="image-mapper-shape"/></a>
    <a href="block/bio/1.pdf" target="_blank"><rect x="599" y="893" width="112" height="511" class="image-mapper-shape"/></a>
  </g>

  <g id="group-2" transform="translate(1024,0)">
    <image href="image/2.png" width="1024" height="2454" data-image-url="image/2.png" class="base-image"/>
</g>

  <g id="group-3" transform="translate(0,2454)">
    <image href="image/3.png" width="1024" height="2454" data-image-url="image/3.png" class="base-image"/>
</g>

  <g id="group-4" transform="translate(1024,2454)">
    <image href="image/4.png" width="1024" height="2454" data-image-url="image/4.png" class="base-image"/>
</g>

  <script>
    const allGroups = document.querySelectorAll('g');
    const clipDefs = document.getElementById('clip-defs');
    let activeHover = null;
    const ORIGINAL_IMAGE_HEIGHT = 2454; 
    const HOLD_DURATION = 500; // الفترة الزمنية للضغط المطول بالمللي ثانية

    // عشان كل رابط يبقى له الـ ZoomPart بتاعه
    const zoomParts = new Map();
    const clipPaths = new Map();

    function startHover(rect, x, y, width, height, offsetX, offsetY, imageURL, imageWidth, imageHeight) {
        // التأكد من إيقاف أي hover سابق
        if (activeHover && activeHover !== rect) stopHover(activeHover);
        if (activeHover === rect) return;
        activeHover = rect;
        rect._hoverStarted = true;

        let clipPathId = `clip-${Date.now()}`;

        let clip = document.createElementNS('http://www.w3.org/2000/svg','clipPath');
        clip.setAttribute('id', clipPathId);
        let clipRect = document.createElementNS('http://www.w3.org/2000/svg','rect');
        clipRect.setAttribute('x', x + offsetX); 
        clipRect.setAttribute('y', y + offsetY); 
        clipRect.setAttribute('width', width);
        clipRect.setAttribute('height', height);
        clip.appendChild(clipRect);
        clipDefs.appendChild(clip);
        clipPaths.set(rect, clip); // حفظ الـ ClipPath

        let zoomPart = document.createElementNS('http://www.w3.org/2000/svg','image');
        zoomPart.setAttribute('href', imageURL);
        zoomPart.setAttribute('width', imageWidth);
        zoomPart.setAttribute('height', imageHeight);
        zoomPart.setAttribute('class','zoom-part');
        zoomPart.setAttribute('clip-path', `url(#${clipPathId})`);

        zoomPart.setAttribute('x', offsetX);
        zoomPart.setAttribute('y', offsetY);

        const transformOriginX = x + width/2 + offsetX;
        const transformOriginY = y + height/2 + offsetY;

        zoomPart.style.transformOrigin = `${transformOriginX}px ${transformOriginY}px`;
        zoomPart.style.opacity = 0;

        rect.ownerSVGElement.appendChild(zoomPart); 
        zoomParts.set(rect, zoomPart); // حفظ الـ ZoomPart

        const scale = 1.1;
        rect.style.transformOrigin = `${x + width/2}px ${y + height/2}px`;
        rect.style.transform = `scale(${scale})`;

        zoomPart.style.transform = `scale(${scale})`;
        zoomPart.style.opacity = 1;

        let hue = 0;
        rect._animationId = setInterval(() => {
          hue = (hue + 1) % 360;
          const glow = `drop-shadow(0 0 8px hsl(${hue},100%,55%)) drop-shadow(0 0 14px hsl(${(hue+60)%360},100%,60%))`;
          rect.style.filter = glow;
          zoomPart.style.filter = glow;
        }, 100);
      }

      function stopHover(rect) {
        if(!activeHover || activeHover !== rect) return;

        rect.style.transform = 'scale(1)';
        rect.style.filter = 'none';

        if(rect._animationId) clearInterval(rect._animationId);

        const zoomPart = zoomParts.get(rect);
        if(zoomPart){ zoomPart.remove(); zoomParts.delete(rect); }

        const clip = clipPaths.get(rect);
        if(clip){ clip.remove(); clipPaths.delete(rect); }

        activeHover = null;
        rect._hoverStarted = false;
        rect._holdTimer = null; 
      }

    function attachHover(rect, index) {
      // تعريف خصائص خاصة بكل مستطيل
      rect._holdTimer = null;
      rect._hoverStarted = false;
      rect._isTouch = false;
      rect._animationId = null;

      const parentGroup = rect.closest('g');
      const baseImage = parentGroup ? parentGroup.querySelector('.base-image') : null;
      const imageURL = baseImage ? baseImage.getAttribute('data-image-url') : 'image/1.png';
      const imageWidth = baseImage ? parseFloat(baseImage.getAttribute('width')) : 1024;
      const imageHeight = baseImage ? parseFloat(baseImage.getAttribute('height')) : ORIGINAL_IMAGE_HEIGHT;

      const transform = parentGroup.getAttribute('transform');
      let offsetX = 0;
      let offsetY = 0;
      if (transform) {
        const match = transform.match(/translate\(([^,]+),([^)]+)\)/);
        if (match) {
          offsetX = parseFloat(match[1]) || 0;
          offsetY = parseFloat(match[2]) || 0;
        }
      }

      const x = parseFloat(rect.getAttribute('x'));
      const y = parseFloat(rect.getAttribute('y'));
      const width = parseFloat(rect.getAttribute('width'));
      const height = parseFloat(rect.getAttribute('height'));
      const anchor = rect.closest('a'); 

      const handlePress = (e) => {
        if(rect._holdTimer || rect._hoverStarted) return;

        rect._isTouch = (e.type === 'touchstart');

        // نمنع الفتح التلقائي للرابط عشان ندي فرصة للضغط المطول يشتغل
        e.preventDefault(); 

        // لو في عنصر تاني معموله Hover، نوقفه
        if (activeHover && activeHover !== rect) stopHover(activeHover);

        // بدأ مؤقت الضغط المطول
        rect._holdTimer = setTimeout(() => {
          // لو المؤقت خلص بدون ما يتلغي (يعني كان ضغط مطول)
          startHover(rect, x, y, width, height, offsetX, offsetY, imageURL, imageWidth, imageHeight);
          rect._holdTimer = null;
        }, HOLD_DURATION);
      };

      const handleRelease = (e) => {
        // نمنع أي سلوك افتراضي للـ 'mouseup' أو 'touchend' عشان نتحكم في فتح الرابط بنفسنا
        if(e.type === 'mouseup' || e.type === 'touchend') {
            e.preventDefault();
        }

        if(rect._holdTimer){
          // ضغطة سريعة -> نفتح الرابط
          clearTimeout(rect._holdTimer);
          rect._holdTimer = null;
          if (anchor) {
            window.open(anchor.href, anchor.target || '_self');
          }
        } else if (rect._hoverStarted) {
          // ضغطة مطولة (الـ Hover اشتغل) -> نفتح الرابط ونوقف الـ Hover
          if (anchor) {
            window.open(anchor.href, anchor.target || '_self');
          }
          stopHover(rect);
        }

        // إعادة تعيين الحالة
        rect._hoverStarted = false; 
        rect._isTouch = false;
      };

      const handleCancel = (e) => {
        // لو الإلغاء كان من ماوس (mouseleave) أو touchcancel
        if (e.type === 'touchcancel' || (e.type === 'mouseleave' && !rect._isTouch)) {
            if(rect._holdTimer){
              clearTimeout(rect._holdTimer);
              rect._holdTimer = null;
            }
            stopHover(rect);
            // إعادة تعيين الحالة
            rect._hoverStarted = false; 
            rect._isTouch = false;
        }
      };

      // ربط أحداث اللمس (للموبايل)
      rect.addEventListener('touchstart', handlePress, {passive: false});
      rect.addEventListener('touchend', handleRelease);
      rect.addEventListener('touchcancel', handleCancel);

      // ربط أحداث الماوس (للكمبيوتر)
      rect.addEventListener('mousedown', handlePress, {passive: false});
      rect.addEventListener('mouseup', handleRelease);
      rect.addEventListener('mouseleave', handleCancel);
    }

    // لِف على كل الـ groups وخد منهم كل الـ rects اللي ليها class='image-mapper-shape'
    allGroups.forEach(group => {
        group.querySelectorAll('.image-mapper-shape').forEach((rect, i) => attachHover(rect, i + Date.now()));
    });

    // لِف على كل الـ groups عشان الـ Observer يراقبهم كلهم لو ضفت روابط جديدة
    allGroups.forEach(group => {
        const observer = new MutationObserver(mutations => {
          mutations.forEach(mutation => {
            mutation.addedNodes.forEach((node, i) => {
              if(node.tagName==='A'){
                const rect = node.querySelector('rect.image-mapper-shape');
                if(rect) attachHover(rect, Date.now()+i);
              }
            });
          });
        });
        observer.observe(group,{childList:true, subtree:true});
    });

  </script>
</body>
</html>