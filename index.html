<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <meta property="og:title" content=" ">
  <meta property="og:description" content=" ">
  <meta property="og:image" content=" ">

  <style>

    html, body {
      margin: 0;
      padding: 0;
      background-color: black;
      height: 100vh;
      overflow: auto;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }

    svg {
      display: block;
      max-width: 100vw;
      height: 100%;
      width: auto;
    }

    .image-mapper-shape {
      fill: transparent;
      stroke: yellow;
      stroke-width: 2px;
      transform-origin: center center;
      transition: transform 0.3s ease, filter 0.3s ease;
    }
    .red-stroke { stroke: red; }
    .blue-stroke { stroke: blue; }

    .zoom-part {
      pointer-events: none;
      transition: transform 0.3s ease, filter 0.3s ease, opacity 0.3s ease;
      image-rendering: auto;
    }
  </style>
</head>
<body>
  <svg xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1993/xlink"
       viewBox="0 0 2048 4908"
       preserveAspectRatio="xMidYMid meet"
       id="main-svg"> 
    <defs id="clip-defs"></defs>

    <g transform="translate(0,0)" id="group-1">
      <image x="0" y="0" xlink:href="image/1.png" width="1024" height="2454" id="base-image-1"/>

      <a href="block/physio/1.pdf"><rect x="254" y="423" width="114" height="467" class="image-mapper-shape"/></a>
      <a href="block/histo/1.pdf"><rect x="253" y="1403" width="114" height="438" class="image-mapper-shape"/></a>
      <a href="block/physio/2.pdf"><rect x="484" y="314" width="113" height="459" class="image-mapper-shape"/></a>
      <a href="block/physio/3.pdf"><rect x="488" y="1838" width="108" height="441" class="image-mapper-shape"/></a>
      <a href="block/bio/1.pdf"><rect x="599" y="893" width="112" height="511" class="image-mapper-shape"/></a>
    </g>

    <g transform="translate(1024,0)" id="group-2">
      <image x="0" y="0" xlink:href="image/2.png" width="1024" height="2454" id="base-image-2" preserveAspectRatio="xMidYMid meet"/>

      </g>

    <g transform="translate(0,2454)" id="group-3">
      <image x="0" y="0" xlink:href="image/3.png" width="1024" height="2454" id="base-image-3"/>

      </g>

    <g transform="translate(1024,2454)" id="group-4">
      <image x="0" y="0" xlink:href="image/4.png" width="1024" height="2454" id="base-image-4"/>

      </g>

    <script>
      const mainSvg = document.getElementById('main-svg');
      const clipDefs = document.getElementById('clip-defs');

      const activeState = {
          rect: null,
          zoomPart: null,
          animationId: null,
          clipPathId: null
      };

      const groups = document.querySelectorAll('g'); 

      function getTransformX(groupElement) {
          const transformAttr = groupElement.getAttribute('transform');
          if (!transformAttr) return 0;
          const match = transformAttr.match(/translate\(\s*([\d\.-]+)\s*,\s*([\d\.-]+)\s*\)/);
          return match ? parseFloat(match[1]) : 0; 
      }

      function getTransformY(groupElement) {
          const transformAttr = groupElement.getAttribute('transform');
          if (!transformAttr) return 0;
          const match = transformAttr.match(/translate\(\s*([\d\.-]+)\s*,\s*([\d\.-]+)\s*\)/);
          return match ? parseFloat(match[2]) : 0; 
      }

      function getGroupImage(parentGroup) {
          const baseImage = parentGroup.querySelector('image');
          if (!baseImage) return null;

          const IMAGE_SRC = baseImage.getAttribute('href') || baseImage.getAttribute('xlink:href');
          const IMAGE_WIDTH = parseFloat(baseImage.getAttribute('width'));
          const IMAGE_HEIGHT = parseFloat(baseImage.getAttribute('height'));

          if (!IMAGE_SRC || isNaN(IMAGE_WIDTH) || isNaN(IMAGE_HEIGHT)) return null;

          return { 
              src: IMAGE_SRC, 
              width: IMAGE_WIDTH, 
              height: IMAGE_HEIGHT
          };
      }

      function cleanupHover() {
        if (!activeState.rect) return;

        if(activeState.animationId) clearInterval(activeState.animationId);

        activeState.rect.style.transform = 'scale(1)';
        activeState.rect.style.filter = 'none';

        if(activeState.zoomPart){ activeState.zoomPart.remove(); }

        const currentClip = document.getElementById(activeState.clipPathId);
        if(currentClip) currentClip.remove();

        activeState.rect = null;
        activeState.zoomPart = null;
        activeState.animationId = null;
        activeState.clipPathId = null;
      }


      function attachHover(rect, i) {

        const anchor = rect.closest('a');

        const clipPathId = `clip-${i}-${Date.now()}`;
        const scale = 1.1;
        const parentGroup = rect.closest('g'); 

        const imageData = getGroupImage(parentGroup); 
        if (!imageData) return; 

        const groupOffsetX = getTransformX(parentGroup);
        const groupOffsetY = getTransformY(parentGroup); 

        rect.setAttribute('data-index', i);

        // ğŸ’» Ø­Ø¯Ø« Ø§Ù„Ù…Ø§ÙˆØ³ Ù„Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±
        rect.addEventListener('mouseover', startHover);
        rect.addEventListener('mouseout', stopHover);

        // ğŸ“± Ø­Ø¯Ø« Ø§Ù„Ù„Ù…Ø³ Ù„Ù„Ù…ÙˆØ¨Ø§ÙŠÙ„: startHover Ø¹Ù†Ø¯ Ø§Ù„Ù„Ù…Ø³
        rect.addEventListener('touchstart', startHover);

        // ğŸ†• Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ: touchend Ø¨ÙŠÙ‚ÙÙ„ Ø§Ù„Ù‡Ø§ÙØ± ÙˆØ¨ÙŠÙØªØ­ Ø§Ù„Ø±Ø§Ø¨Ø· ÙŠØ¯ÙˆÙŠØ§Ù‹ Ø¨Ø¯ÙˆÙ† delay
        rect.addEventListener('touchend', (e) => {
             // Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù€ Hover ÙÙˆØ±Ø§Ù‹
             cleanupHover(); 

             // ğŸ†• ÙØªØ­ Ø§Ù„Ø±Ø§Ø¨Ø· ÙŠØ¯ÙˆÙŠØ§Ù‹ Ù„Ø¶Ù…Ø§Ù† Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ delay
             if (anchor && anchor.href && anchor.href !== '#') {
                e.preventDefault(); // Ù…Ù†Ø¹ Ø³Ù„ÙˆÙƒ Ø§Ù„Ù€ click Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠ Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªØ£Ø®ÙŠØ±
                
                // ØªØ­Ø¯ÙŠØ¯ Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„ÙØªØ­ (Ù†ÙØ³ Ø§Ù„ØªØ§Ø¨ Ù„Ù„Ù…ÙˆØ¨Ø§ÙŠÙ„ØŒ ØªØ§Ø¨ Ø¬Ø¯ÙŠØ¯ Ù„Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±)
                const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0) || (window.innerWidth < 800);
                
                // Ù„Ùˆ Ù…Ø´ Ù…ÙˆØ¨Ø§ÙŠÙ„ ÙˆØ¹Ù†Ø¯Ù†Ø§ target="_blank" (Ù…Ù† setLinkTarget)ØŒ Ù†ÙØªØ­ ÙÙŠ Ù†Ø§ÙØ°Ø© Ø¬Ø¯ÙŠØ¯Ø©
                if (!isMobile && anchor.getAttribute('target') === '_blank') {
                    window.open(anchor.href, '_blank');
                } else {
                    window.location.href = anchor.href;
                }
             }
        });

        // âŒ Ø­Ø°ÙÙ†Ø§ Ø£ÙŠ Ø­Ø¯Ø« 'click' Ø¥Ø¶Ø§ÙÙŠ Ù„Ù…Ù†Ø¹ Ø§Ù„ØªØ¹Ø§Ø±Ø¶.
        
        function startHover() {
          if(activeState.rect === rect) return;

          cleanupHover(); 

          activeState.rect = rect;
          activeState.clipPathId = clipPathId;

          const x = parseFloat(rect.getAttribute('x'));
          const y = parseFloat(rect.getAttribute('y'));
          const width = parseFloat(rect.getAttribute('width'));
          const height = parseFloat(rect.getAttribute('height'));

          // Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„Ù‚Ø© ÙÙŠ Ø§Ù„Ù€ SVG ÙƒÙ„Ù‡ (Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ù€ Clip Path)
          const absoluteX = x + groupOffsetX; 
          const absoluteY = y + groupOffsetY; 

          let clip = document.createElementNS('http://www.w3.org/2000/svg','clipPath');
          clip.setAttribute('id', clipPathId);
          let clipRect = document.createElementNS('http://www.w3.org/2000/svg','rect');
          clipRect.setAttribute('x', absoluteX);
          clipRect.setAttribute('y', absoluteY);
          clipRect.setAttribute('width', width);
          clipRect.setAttribute('height', height);
          clipDefs.appendChild(clip).appendChild(clipRect);


          const zoomPart = document.createElementNS('http://www.w3.org/2000/svg','image');

          zoomPart.setAttribute('href', imageData.src);
          zoomPart.setAttribute('width', imageData.width);
          zoomPart.setAttribute('height', imageData.height);
          zoomPart.setAttribute('class','zoom-part');
          zoomPart.setAttribute('clip-path', `url(#${clipPathId})`);

          // ØªØ­Ø¯ÙŠØ¯ Ù…ÙƒØ§Ù† Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…Ù‚Ø·ÙˆØ¹Ø© Ø¨ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ø¥Ø²Ø§Ø­Ø© Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø©
          zoomPart.setAttribute('x', groupOffsetX); 
          zoomPart.setAttribute('y', groupOffsetY); 

          // Ø§Ù„ØªÙƒØ¨ÙŠØ± Ù‡ÙŠØ­ØµÙ„ Ù…Ù† Ù…Ù†ØªØµÙ Ø§Ù„Ù…Ø³ØªØ·ÙŠÙ„ Ø§Ù„Ù…Ø·Ù„Ù‚
          zoomPart.style.transformOrigin = `${absoluteX + width/2}px ${absoluteY + height/2}px`;
          zoomPart.style.opacity = 0;

          mainSvg.appendChild(zoomPart);
          activeState.zoomPart = zoomPart;

          // ØªØ£Ø«ÙŠØ± Ø§Ù„Ø­Ø±ÙƒØ© Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³ØªØ·ÙŠÙ„ Ø§Ù„Ø´ÙØ§Ù Ù†ÙØ³Ù‡
          rect.style.transformOrigin = `${x + width/2}px ${y + height/2}px`;
          rect.style.transform = `scale(${scale})`;
          zoomPart.style.transform = `scale(${scale})`;
          zoomPart.style.opacity = 1;

          let hue = 0;
          const animationId = setInterval(() => {
            hue = (hue + 1) % 360;
            const glow = `drop-shadow(0 0 8px hsl(${hue},100%,55%)) drop-shadow(0 0 14px hsl(${(hue+60)%360},100%,60%))`;
            rect.style.filter = glow;
            if(zoomPart) zoomPart.style.filter = glow;
          }, 100);
          activeState.animationId = animationId;
        }

        function stopHover(e) {
          const targetRect = e ? (e.target.tagName === 'rect' ? e.target : e.target.closest('a')?.querySelector('.image-mapper-shape')) : rect;

          if(targetRect === activeState.rect && e.type === 'mouseout'){
              cleanupHover();
          }
        }
      }

      groups.forEach(group => {
          group.querySelectorAll('.image-mapper-shape').forEach((rect, i) => attachHover(rect, i));

          const observer = new MutationObserver(mutations => {
            mutations.forEach(mutation => {
              mutation.addedNodes.forEach((node, i) => {
                if(node.tagName==='A'){
                  const rect = node.querySelector('rect.image-mapper-shape');
                  if(rect) attachHover(rect, Date.now()+i);
                }
              });
            });
          });
          observer.observe(group,{childList:true, subtree:true});
      });

      function setLinkTarget() {
        const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0) || (window.innerWidth < 800);

        const allLinks = document.querySelectorAll('a[xlink\\:href], a[href]');

        allLinks.forEach(link => {
          if (isMobile) {
             // Ø¥Ø²Ø§Ù„Ø© target="_blank" Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙˆØ¨Ø§ÙŠÙ„ Ø¹Ø´Ø§Ù† ÙŠÙØªØ­ ÙÙŠ Ù†ÙØ³ Ø§Ù„ØªØ§Ø¨ ÙˆÙŠØ³Ù‡Ù„ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ù€ touchend
            link.removeAttribute('target');
          } else {
            link.setAttribute('target', '_blank'); 
          }
        });
      }

      setLinkTarget();
    </script>
</body>
</html>